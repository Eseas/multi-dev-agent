# 다중 AI 에이전트 기반 개발 시스템 제안서

## 1. 개요

### 1.1 배경 및 동기

전통적인 개발 프로세스에서는 개발자가 기획, 구현, 리뷰, 테스트를 모두 직접 수행한다. 이는 시간이 많이 소요되며, 리뷰와 테스트가 생략되거나 부실하게 이루어지는 경우가 많다.

AI 코딩 어시스턴트의 발전으로, 이제 **AI 에이전트를 활용한 개발팀 시뮬레이션**이 가능해졌다. 본 제안서는 다중 AI 에이전트를 활용하여 개발자, 리뷰어, 테스터 역할을 수행하고, 자동화된 품질 관리를 통해 고품질 구현을 달성하는 시스템을 제안한다.

**핵심 개념**: 사용자는 기획자로서 요구사항을 정의하고, AI 에이전트들이 개발팀으로서 구현, 리뷰, 테스트를 수행한다. 필요에 따라 여러 구현 방법을 동시에 탐색하여 비교할 수도 있다.

**적용 범위**: 이 시스템은 GitHub 저장소로 관리되는 모든 소프트웨어 프로젝트에 적용 가능하다. 타겟 프로젝트를 clone하여 기존 코드 위에서 작업하므로, 언어나 프레임워크에 제한이 없다.

### 1.2 비전

**"AI 개발팀과 협업하여 고품질 구현을 달성한다"**

이 시스템은 다음을 가능하게 한다:
- 👥 **AI 개발팀**: 개발자, 리뷰어, 테스터 역할을 AI 에이전트가 수행
- ✅ **자동화된 품질 관리**: 모든 구현에 대해 코드 리뷰와 테스트 자동 수행
- 🎯 **유연한 탐색**: 필요시 여러 방법을 동시에 구현하여 비교 (선택사항)
- 📊 **데이터 기반 의사결정**: 실제 구현 결과와 테스트 데이터로 판단
- 👤 **인간 중심 기획**: 사용자가 요구사항과 탐색 방향을 결정

### 1.3 핵심 가치

#### 1.3.1 품질 중심 개발 (Quality-First Development)
모든 구현에 대해 **자동화된 코드 리뷰와 테스트**를 수행하여 품질을 보장한다. 개발자가 직접 리뷰와 테스트를 수행할 필요 없이, AI 에이전트들이 체계적으로 품질을 검증한다.

#### 1.3.2 유연한 탐색 (Flexible Exploration, 선택사항)
필요에 따라 여러 구현 방법을 동시에 시도하여 비교할 수 있다. 학습 목적, 기술 검증, 또는 불확실한 상황에서 여러 옵션을 실제로 구현하고 비교하는 것이 가능하다.

#### 1.3.3 데이터 기반 의사결정 (Data-Driven Decision)
직관이나 선호도가 아닌, 실제 구현 결과와 테스트 데이터를 바탕으로 결정한다. 여러 방법을 비교할 때는 객관적인 비교 보고서를 제공받는다.

### 1.4 목표

#### 주요 목표
1. **품질 보장**: 자동화된 코드 리뷰와 테스트로 모든 구현의 품질 검증
2. **시간 절약**: 사람이 직접 리뷰/테스트를 수행할 필요 없음
3. **유연한 탐색**: 필요시 여러 구현 방법을 비교하여 최선 선택 (선택사항)
4. **체계적 프로세스**: 기획 → 구현 → 리뷰 → 테스트 → 통합의 완전한 자동화

#### 부가 목표
- **명확한 역할 분담**: 사람은 기획과 의사결정, AI는 구현과 품질 관리
- **실시간 모니터링**: 알림 시스템으로 진행 상황 파악
- **재현 가능성**: 모든 단계와 결정 근거 기록
- **리스크 분산**: 여러 구현 비교 시(N>1) 대안 확보

---

## 2. 시스템 개념

### 2.1 핵심 개념: 파이프라인 아키텍처

시스템은 Phase 0(기획)부터 Phase 6(통합)까지의 7단계와, Phase 0과 Phase 1 사이의 **기획서 유효성 검증** 단계로 구성된 **파이프라인**으로 동작한다. 각 단계는 명확한 입력과 출력을 가지며, 이전 단계의 결과를 다음 단계가 활용하는 구조이다.

**기본 흐름 (N=1, 단일 구현)**:
```
요구사항 → [0단계: 기획] → [검증] → [1단계: 분석] → [2단계: 구현]
→ [3단계: 리뷰/테스트] → [6단계: 사용자 git 통합]
```

**비교 흐름 (N≥2, 다중 구현, 선택사항)**:
```
요구사항 → [0단계: 기획] → [검증] → [1단계: 분석] → [2단계: N개 병렬 구현]
→ [3단계: 2N개 리뷰/테스트] → [4단계: 비교] → [5단계: 선택] → [6단계: 사용자 git 통합]
```

**주요 특징**:
- 기획서 검증: Phase 0 완료 후 자동 유효성 검사 (잘못된 기획서 조기 차단)
- N=1: 단일 구현 → 리뷰/테스트 → 통합 (빠르고 효율적)
- N≥2: 병렬 구현 → 각각 리뷰/테스트 → 비교 → 선택 → 통합 (철저한 비교)

### 2.2 체크포인트 시스템 (Checkpoint System)

사용자는 실행 중 잘못된 방향을 **조기에** 발견하고 수정할 수 있어야 한다.

#### Phase 1 필수 확인 (기본값)

Architect Agent가 구현 계획을 작성하면, 시스템은 **자동으로 일시정지**하고 사용자의 확인을 요청한다.

**프로세스**:
```
Phase 0 (기획) → Phase 1 (Architect) → 구현 계획 생성
     ↓
💡 [CHECKPOINT] 시스템 일시정지 + 알림
     ↓
사용자 검토: approaches.json 확인
     ↓
선택: ✅ 승인 | 🔄 수정 | ❌ 중단
     ↓
Phase 2-6 진행 (승인 시)
```

**사용자 선택지** (N=1인 경우):
- **✅ 전체 승인 (Approve)**: "구현 계획이 정확합니다" → Phase 2 진행
- **🔄 전체 수정 (Revise)**: "이 부분을 수정해주세요" → Phase 1 재실행
- **❌ 전체 중단 (Abort)**: "기획부터 다시 해야겠습니다" → 작업 중단

**사용자 선택지** (N≥2인 경우, 개별 제어 가능):
- **✅ 개별/전체 승인 (Approve)**: 선택한 approach(들)만 Phase 2로 진행
- **🔄 개별 수정 (Revise)**: 특정 approach만 재생성 (나머지 유지)
- **❌ 개별 반려 (Reject)**: 특정 approach를 완전히 제거 (N 감소)
- **⏸️ 보류 (Keep Pending)**: 나중에 결정 (일단 보류)

**장점**:
- ✅ 구현 방향 오류를 **구현 전에** 차단
- ✅ 시간/비용 낭비 방지 (좋은 계획은 바로 진행)
- ✅ 유연한 제어 (개별 승인/수정/반려 가능)
- ✅ 구현 계획은 짧아서 1-2분이면 확인 가능

#### 개별 승인/수정/반려 (N≥2인 경우)

여러 구현 계획이 생성되었을 때, 각 approach를 **독립적으로** 제어할 수 있다.

**예시 시나리오** (N=3으로 시작):

```
Phase 1 완료:
  - Approach 1: JWT 토큰 기반 인증 (✅ 완벽함)
  - Approach 2: 세션 기반 인증 (✅ 좋음)
  - Approach 3: OAuth2 하이브리드 (❌ 과도하게 복잡, 불필요)

사용자 결정:
  - Approach 1, 2 승인 → 바로 Phase 2로
  - Approach 3 반려 → 제거 (고려 대상에서 삭제)

결과: N=2로 축소, Approach 1, 2만 구현 진행
```

**CLI 명령어**:

```bash
# 1. 일부만 승인 (나머지는 자동으로 보류/제거)
python -m orchestrator.main approve task-XXX --approaches 1,2

# 2. 일부 승인 + 나머지 명시적 반려
python -m orchestrator.main approve task-XXX --approaches 1,2 --reject 3

# 3. 특정 approach만 수정 요청
python -m orchestrator.main revise task-XXX --approach 3 \
  --feedback "Redis 대신 PostgreSQL 사용"

# 4. 수정된 것 나중에 승인
python -m orchestrator.main approve task-XXX --approach 3

# 5. 대화형 모드 (각 approach를 순차적으로 검토)
python -m orchestrator.main approve task-XXX --interactive
```

**상태 관리**:

각 approach는 독립적인 상태를 가짐:

| 상태 | 설명 | 다음 동작 |
|------|------|----------|
| `pending` | 대기 중 | 사용자 확인 필요 |
| `approved` | 승인됨 | Phase 2로 진행 |
| `in_revision` | 수정 중 | Architect 재실행 중 |
| `rejected` | 반려됨 | 제거 (더 이상 진행 안 함) |

**장점**:
- ✅ **낭비 최소화**: 좋은 계획은 바로 진행, 나쁜 계획만 수정/제거
- ✅ **유연성**: 각 approach를 독립적으로 제어
- ✅ **효율성**: 승인된 것은 먼저 시작, 수정 중인 것은 나중에 합류
- ✅ **동적 N**: 필요에 따라 N이 줄어들거나 늘어남

#### 설정

```yaml
# config.yaml
pipeline:
  checkpoint_phase1: true  # Phase 1 체크포인트 (기본값, 권장)
```

**참고**: 향후 확장 시 다른 Phase에도 체크포인트 추가 가능 (예: Phase 2, Phase 3)

### 2.3 유연한 구현 개수 (N)

시스템은 **사용자가 기획 단계(Phase 0)에서 결정한 구현 개수(N)**에 따라 동작한다.

#### N=1: 단일 고품질 구현 (일반적 케이스)
- **적용 상황**: 일반적인 기능 개발, 명확한 구현 방법이 있는 경우
- **프로세스**: 기획 → 구현 → 리뷰 → 테스트 → 통합
- **장점**: 빠른 개발, 자동화된 품질 관리
- **비용/시간**: 1배 (기준선)

#### N≥2: 다중 구현 비교 (선택사항)
- **적용 상황**:
  - 여러 기술 스택 중 선택이 필요할 때
  - 학습 목적으로 여러 방법을 비교하고 싶을 때
  - 중요한 결정에서 여러 옵션을 실제로 검증하고 싶을 때
- **프로세스**: 기획 → N개 병렬 구현 → 각각 리뷰/테스트 → 비교 분석 → 선택 → 통합
- **장점**: 객관적 비교, 리스크 분산, 학습 효과
- **비용/시간**: N배 (N개 구현)

**결정 권한**: 사용자가 Phase 0에서 기획서에 명시
- 예시 1: "구현 방법: 1개 (JWT 토큰 기반 인증)"
- 예시 2: "구현 방법: 2개 (JWT vs 세션 비교)"
- 예시 3: "구현 방법: 3개 (JWT vs 세션 vs OAuth2 비교)"

### 2.4 전체 워크플로우

```
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃           Notification System (알림 시스템)              ┃
┃            모든 단계 완료/실패 시 실시간 알림                 ┃
┗━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                      ▲
                      │ (모든 단계 모니터링)
                      │
┏━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃            Orchestrator (오케스트레이터)               ┃
┃         planning/completed/ 폴더를 감시하며            ┃
┃         기획서에 명시된 N개 구현을 관리하고                ┃
┃               전체 파이프라인 실행                      ┃
┗━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                      │
                      ▼
╔═════════════════════════════════════════════════════════╗
║           Phase 0: Planning (기획 단계)                   ║
║                    사람 주도                              ║
╚═════════════════════════════════════════════════════════╝
                      │
    ┌─────────────────────────────────────────┐
    │   Human + Claude Code (대화형 기획)        │
    │                                         │
    │   작업 위치:                              │
    │   planning/in-progress/task-XXX/        │
    │                                         │
    │   결정 사항:                              │
    │   • 구현할 기능의 명확한 정의                 │
    │   • 구현 방법의 개수 (N, 기본 1개)            │
    │   • 각 방법의 구체적 설명                    │
    │   • 성공 기준 및 제약사항                    │
    │                                         │
    │   출력: planning-spec.md                 │
    └─────────────────────────────────────────┘
                      │
                      ▼
            [기획서를 completed/로 이동]
                      │
                      ▼
          🔔 알림: "새로운 기획서 감지됨"
                      │
                      ▼
╔═════════════════════════════════════════════════════════╗
║        Spec Validation (기획서 유효성 검증)                  ║
║                 시스템 자동 실행                             ║
╚═════════════════════════════════════════════════════════╝
                      │
    ┌─────────────────────────────────────────┐
    │       Spec Validator                   │
    │                                         │
    │   검증 항목:                              │
    │   1. 마크다운 구조 및 최소 길이              │
    │   2. 구현 방법 섹션 존재 여부               │
    │   3. 기술 스택 명시 여부                    │
    │   4. N 일관성 (헤딩 vs 본문)               │
    │                                         │
    │   결과:                                  │
    │   ✅ 통과 → Phase 1 진행                  │
    │   ❌ 실패 → 사용자 알림 + 수정 후 재검증     │
    └─────────────────────────────────────────┘
                      │ (검증 통과 시)
                      ▼
╔═════════════════════════════════════════════════════════╗
║      Phase 1: Architecture Analysis (분석 단계)           ║
║                    AI 자동 실행                           ║
╚═════════════════════════════════════════════════════════╝
                      │
    ┌──────────────────────────────────────────┐
    │        Architect Agent                   │
    │                                          │
    │   입력: planning-spec.md                  │
    │   작업: 기획서 분석 후                       │
    │         N개 구체적 구현 방향 도출             │
    │   출력: approaches.json                  │
    │                                         │
    │   • 각 방법을 구체화                        │
    │   • 기술 스택 선정                         │
    │   • 장단점 분석                            │
    └─────────────────────────────────────────┘
                      │
                      ▼
         🔔 알림: "아키텍처 분석 완료"
                      │
                      ▼
╔═════════════════════════════════════════════════════════╗
║           💡 CHECKPOINT: Phase 1 완료                    ║
║                  사람 승인 필요                            ║
╚═════════════════════════════════════════════════════════╝
                      │
    ┌─────────────────────────────────────────┐
    │       사용자 구현 계획 검토                  │
    │                                         │
    │   확인 사항:                              │
    │   • approaches.json 검토                 │
    │   • 기술 스택 적절성                        │
    │   • 구현 방향 정확성                        │
    │                                         │
    │   선택:                                  │
    │   ✅ 승인 → Phase 2 진행                  │
    │   🔄 수정 → Phase 1 재실행                │
    │   ❌ 중단 → 전체 작업 취소                  │
    └─────────────────────────────────────────┘
                      │ (승인 시)
                      ▼
          [동적 환경 생성: impl-1 ~ impl-N]
                      │
                      ▼
╔═════════════════════════════════════════════════════════╗
║        Phase 2: Implementation (구현 단계)                ║
║                 AI 병렬 자동 실행                          ║
╚═════════════════════════════════════════════════════════╝
                      │
         ┌────────────┼────────────┐
         ▼            ▼            ▼
    ┌────────┐  ┌────────┐  ┌────────┐
    │ Impl 1 │  │ Impl 2 │  │ Impl N │
    │        │  │        │  │        │
    │ Input: │  │ Input: │  │ Input: │
    │ appr-1 │  │ appr-2 │  │ appr-N │
    │        │  │        │  │        │
    │ Output:│  │ Output:│  │ Output:│
    │ impl-1/│  │ impl-2/│  │ impl-N/│
    └────────┘  └────────┘  └────────┘
         │            │            │
         └────────────┼────────────┘
                      ▼
        🔔 알림: "모든 구현 완료 (N개)"
                      │
                      ▼
╔═════════════════════════════════════════════════════════╗
║    Phase 3: Review & Testing (리뷰/테스트 단계)             ║
║                 AI 병렬 자동 실행                          ║
╚═════════════════════════════════════════════════════════╝
                      │
         ┌────────────┴────────────┐
         ▼                         ▼
    ┌─────────────┐          ┌─────────────┐
    │  Reviewer   │          │   Tester    │
    │   Agents    │          │   Agents    │
    │  (N개 병렬)   │          │  (N개 병렬)  │
    │             │          │             │
    │   각 구현체   │          │ 각 구현체     │
    │   코드 리뷰   │          │ 테스트 작성    │
    │   장단점 분석  │          │ 실행 및 결과   │
    │             │          │             │
    │ Output:     │          │ Output:     │
    │ review-N.md │          │ test-N.md   │
    └─────────────┘          └─────────────┘
         │                         │
         └────────────┬────────────┘
                      ▼
       🔔 알림: "리뷰 및 테스트 완료"
                      │
                      ▼
              ┌───── N=? ─────┐
              │               │
          N=1 │           N≥2 │
              ▼               ▼
     [Phase 4,5 생략]   ╔══════════════════════╗
              │        ║ Phase 4: Comparison  ║
              │        ║   (비교 분석 단계)      ║
              │        ║    AI 자동 실행        ║
              │        ╚══════════════════════╝
              │               │
              │    ┌──────────────────────┐
              │    │  Comparator Agent    │
              │    │                      │
              │    │  입력: N개 구현 + 리뷰  │
              │    │       + 테스트 결과    │
              │    │  작업: 종합 비교 및     │
              │    │       순위 산정       │
              │    │  출력: comparison-   │
              │    │       report.md      │
              │    └──────────────────────┘
              │               │
              │               ▼
              │        🔔 "비교 분석 완료"
              │               │
              │               ▼
              │        ╔══════════════════════╗
              │        ║ Phase 5: Human      ║
              │        ║  Selection          ║
              │        ║  (사람 승인 단계)      ║
              │        ╚══════════════════════╝
              │               │
              │    ┌──────────────────────┐
              │    │   Human Review       │
              │    │                      │
              │    │ • 각 구현의 실제 코드   │
              │    │ • 리뷰/테스트 결과     │
              │    │ • 비교 분석 및 추천    │
              │    │                      │
              │    │ 선택:                 │
              │    │ ✓ 승인 (decision.json)│
              │    │ ✗ 수정 요청           │
              │    │ ✗ 중단               │
              │    └──────────────────────┘
              │               │
              └───────┬───────┘
                      ▼
╔═════════════════════════════════════════════════════════╗
║         Phase 6: Integration (통합 단계)                  ║
║                    사람 주도 (git)                        ║
╚═════════════════════════════════════════════════════════╝
                      │
    ┌─────────────────────────────────────────┐
    │       사용자 직접 git 통합                  │
    │                                         │
    │   제공 정보:                              │
    │   • 통합 대상 브랜치명                      │
    │   • 변경 요약 (파일, 라인 수)                │
    │   • 리뷰/테스트 결과 요약                   │
    │                                         │
    │   사용자 작업:                             │
    │   • git merge / cherry-pick              │
    │   • 충돌 해결 (필요시)                      │
    │   • worktree 정리 (선택)                  │
    └─────────────────────────────────────────┘
                      │
                      ▼
    🔔 알림: "통합 브랜치: task-XXX/impl-N"
                      │
                      ▼
                 [작업 완료]
```

### 2.5 워크스페이스 개념

시스템은 **오케스트레이터**와 **타겟 프로젝트** 두 가지로 구분된다. 오케스트레이터는 독립된 도구이며, 타겟 프로젝트의 GitHub 저장소를 참조하여 작업한다.

#### 설정

```yaml
# config.yaml
project:
  target_repo: "https://github.com/user/my-web-app"  # 타겟 프로젝트 GitHub URL (필수)
  default_branch: "main"                              # 기본 브랜치 (기본값: main)
```

#### 전체 디렉토리 구조

```
# 오케스트레이터 (이 시스템)
~/multi-agent-system/
├── orchestrator/                # 시스템 코드
├── config.yaml                  # 설정 (타겟 프로젝트 URL 포함)
├── prompts/                     # 에이전트 프롬프트 템플릿
└── workspace/
    ├── planning/
    │   ├── in-progress/         # 기획 작성 중
    │   └── completed/           # 완성된 기획서 (시스템이 감시)
    └── tasks/
        └── task-001/
            ├── manifest.json    # 상태 추적
            ├── timeline.log     # 타임라인
            ├── planning-spec.md # 기획서 복사본
            ├── approaches.json  # Phase 1 출력
            └── implementations/
                ├── impl-1/      # git worktree (branch: task-001/impl-1)
                │   └── (타겟 프로젝트 전체 + AI가 작성한 코드)
                └── impl-2/      # git worktree (branch: task-001/impl-2)
                    └── (타겟 프로젝트 전체 + AI가 작성한 코드)

# 타겟 프로젝트 (사용자의 실제 프로젝트, 별도 위치)
~/projects/my-web-app/
├── .git/
├── src/
└── package.json
```

#### 기획 공간 (Planning Space)
- **in-progress/**: 사람이 Claude Code와 대화하며 기획서를 작성하는 공간
- **completed/**: 완성된 기획서를 두는 공간 (시스템이 감시)

#### 실행 공간 (Execution Space)
- **tasks/task-XXX/**: 각 기획서마다 생성되는 작업 공간
  - 상태 추적 파일 (manifest, timeline)
  - N개의 git worktree 기반 구현 디렉토리 (impl-1, impl-2, ..., impl-N)
  - 각 단계별 결과물 (approaches.json, review, test, comparison)

#### 타겟 프로젝트 연결 방식
- 시스템은 `config.yaml`의 `target_repo`에서 GitHub 저장소를 **clone**
- 각 구현(impl-N)은 **git worktree**로 분리하여 독립적인 작업 공간 생성
- 각 worktree는 전용 브랜치(`task-XXX/impl-N`)에서 작업
- 코드 통합(Phase 6)은 **사용자가 git으로 직접** 수행 (merge, cherry-pick 등)

---

## 3. 단계별 상세 설명

### 3.1 Phase 0: Planning (기획 단계)

**주체**: 사람 + Claude Code (대화형)
**목적**: 명확하고 구조화된 기획서 작성

#### 작업 내용
1. **문제 정의**: 해결하고자 하는 문제를 명확히 정의
2. **요구사항 도출**: 기능/비기능 요구사항 정리
3. **구현 방법 결정**: 하나 또는 여러 개의 방법 선택

#### 핵심 개념: 구현 방법 개수(N) 결정

기획서의 핵심은 **무엇을 구현할지**와 **몇 가지 방법을 비교할지**(N)를 명확히 하는 것이다. 프로젝트의 기술 스택이나 구조는 타겟 프로젝트(GitHub 저장소)에 이미 존재하므로, 기획서에서 별도로 명시할 필요가 없다.

**일반적 케이스 - N=1 (단일 구현)**:

*예시 1: 백엔드 API*
```markdown
## 구현 방법
JWT 토큰 기반 인증을 구현한다.
- 핵심 기능: 로그인, 토큰 발급, 토큰 검증
- 라이브러리: jsonwebtoken, bcrypt
```

*예시 2: 프론트엔드 컴포넌트*
```markdown
## 구현 방법
사용자 프로필 카드 컴포넌트를 구현한다.
- 핵심 기능: 프로필 이미지, 사용자 정보 표시, 편집 버튼
- 접근성: ARIA 레이블, 키보드 네비게이션
```

*예시 3: CLI 도구*
```markdown
## 구현 방법
파일 변환 CLI 도구를 구현한다.
- 핵심 기능: JSON → YAML 변환, 진행 상태 표시, 에러 처리
- 라이브러리: Click, Rich (progress bar)
```

**비교가 필요한 케이스 - N≥2 (다중 구현)**:

*예시 1: 인증 시스템*
```markdown
## 구현 방법 (2개 비교)

### 방법 1: JWT 기반 인증
- 라이브러리: jsonwebtoken, bcrypt
- 예상 장점: 확장성, MSA 친화적
- 예상 단점: 토큰 무효화 복잡

### 방법 2: 세션 기반 인증
- 라이브러리: express-session, bcrypt
- 예상 장점: 구현 단순, 즉시 무효화
- 예상 단점: 서버 메모리 사용
```

*예시 2: 상태 관리*
```markdown
## 구현 방법 (2개 비교)

### 방법 1: Context API + useReducer
- 예상 장점: 내장 기능, 추가 의존성 없음
- 예상 단점: 성능 최적화 수동 필요

### 방법 2: Zustand
- 예상 장점: 간단한 API, 자동 최적화
- 예상 단점: 외부 의존성 추가
```

**언제 N>1을 선택하나요?**
- 여러 기술 스택을 실제로 비교하고 싶을 때
- 학습 목적으로 다양한 접근법을 보고 싶을 때
- 중요한 결정에서 객관적인 비교 자료가 필요할 때
- 단순 호기심으로 "다른 방법은 어떨까?" 궁금할 때

#### 종료 조건
기획서를 `planning/completed/` 폴더로 이동하면 시스템이 자동으로 **기획서 유효성 검증**을 수행한 뒤 다음 단계를 시작한다.

---

### 3.1.1 Spec Validation (기획서 유효성 검증)

**주체**: 시스템 자동 실행 (AI 에이전트 아님, 규칙 기반 검증)
**시점**: Phase 0 완료 직후, Phase 1 시작 전
**목적**: 잘못된 기획서가 Phase 1에 전달되어 API 비용을 낭비하는 것을 방지

#### 왜 필요한가?

기획서가 불완전하거나 형식이 잘못된 채로 Phase 1(Architect Agent)에 전달되면:
- Architect Agent가 기획서를 제대로 파싱하지 못해 **잘못된 구현 계획** 생성
- API 비용이 낭비됨 (Phase 1 실행 비용)
- 실패 원인 파악에 시간 소요

사전 검증은 **비용 없이 즉시** 실행되므로, 문제를 가장 빠르고 저렴하게 차단할 수 있다.

#### 검증 항목

**1단계: 구조 검증 (Structure Validation)**

| 검증 항목 | 검증 내용 | 실패 시 메시지 |
|-----------|----------|--------------|
| 마크다운 형식 | 유효한 마크다운 파일인지 확인 | "기획서가 올바른 마크다운 형식이 아닙니다." |
| 최소 길이 | 의미 있는 내용이 포함되어 있는지 (빈 파일 방지) | "기획서 내용이 너무 짧습니다. 구현할 내용을 구체적으로 작성해주세요." |

**2단계: 내용 검증 (Content Validation)**

| 검증 항목 | 검증 내용 | 실패 시 메시지 |
|-----------|----------|--------------|
| 구현 방법 섹션 | `## 구현 방법` 또는 유사 헤딩 존재 여부 | "구현 방법 섹션이 없습니다. '## 구현 방법' 섹션을 추가해주세요." |
| N 추출 | 본문에서 구현 방법 개수 파악 가능 여부 | "구현 방법의 개수를 파악할 수 없습니다. 명확하게 방법을 구분해주세요." |
| 기술 스택 명시 | 최소 하나의 구체적 기술명 포함 여부 | "기술 스택이 명시되지 않았습니다. 사용할 기술을 구체적으로 적어주세요." |

**3단계: 일관성 검증 (Consistency Validation)**

| 검증 항목 | 검증 내용 | 실패 시 메시지 |
|-----------|----------|--------------|
| N 일관성 | 헤딩에 "(N개 비교)"가 있으면 실제 `### 방법` 개수와 일치하는지 | "구현 방법 개수 불일치: 헤딩에는 2개라 했지만 실제 방법은 3개입니다." |
| N≥2 차별성 | N≥2일 때 각 방법이 서로 다른 핵심 아이디어인지 (같은 이름 방지) | "방법 1과 방법 2의 이름이 동일합니다. 각 방법은 서로 다른 접근법이어야 합니다." |

#### 검증 흐름

```
기획서가 completed/로 이동됨
     ↓
[1단계] 구조 검증
  ├─ 실패 → 🔔 알림 + validation-errors.md 생성 → 수정 후 재검증 대기
  └─ 통과 ↓
[2단계] 내용 검증
  ├─ 실패 → 🔔 알림 + validation-errors.md 생성 → 수정 후 재검증 대기
  └─ 통과 ↓
[3단계] 일관성 검증
  ├─ 실패 → 🔔 알림 + validation-errors.md 생성 → 수정 후 재검증 대기
  └─ 통과 ↓
✅ 검증 통과 → Phase 1 시작
🔔 알림: "기획서 검증 완료, Phase 1 시작"
```

#### 검증 실패 시 처리

1. 기획서는 `completed/`에 **그대로 유지** (파이프라인 진행만 차단)
2. 검증 실패 내역을 같은 디렉토리에 `validation-errors.md` 파일로 생성
3. 사용자에게 **알림**: 실패 원인과 수정 방법 안내
4. 사용자가 기획서를 직접 수정하면 시스템이 파일 변경을 감지하여 **자동 재검증**

#### 검증 실패 보고서 예시

```markdown
# 기획서 검증 실패

## 검증 일시
2025-02-10T15:30:00

## 실패 항목

### ❌ 내용 검증 실패
- **구현 방법 섹션 누락**: '## 구현 방법' 섹션이 없습니다.
  - 수정 방법: 기획서에 `## 구현 방법` 헤딩과 구체적인 구현 내용을 추가하세요.

### ⚠️ 내용 검증 경고
- **기술 스택 불명확**: 구체적인 기술명이 포함되지 않았습니다.
  - 수정 방법: "적절한 기술" 대신 "jsonwebtoken, bcrypt"처럼 명시하세요.
```

#### 설정

```yaml
# config.yaml
validation:
  enabled: true                    # 기획서 검증 활성화 (기본값: true)
  auto_revalidate: true            # 기획서 수정 감지 시 자동 재검증 (기본값: true)
  strict_mode: false               # true: 경고도 실패 처리, false: 오류만 실패 처리
```

**참고**: 검증은 규칙 기반(코드)으로 동작하므로 API 비용이 발생하지 않으며, 밀리초 단위로 즉시 완료된다.

---

### 3.2 Phase 1: Architecture Analysis (아키텍처 분석)

**주체**: Architect AI Agent
**입력**: 완성된 기획서
**출력**: 구체화된 구현 계획 (approaches.json, 1개 또는 N개)

#### 작업 내용
1. **기획서 파싱**: 구현 방법 개수(N), 각 방법의 개요 추출
2. **타겟 프로젝트 분석**: clone된 프로젝트의 기존 코드, 구조, 의존성 파악
3. **방법 구체화**: 각 방법을 실제 구현 가능한 수준으로 상세화
   - 기존 프로젝트 구조에 맞는 구현 가이드 작성
   - 필요한 추가 의존성 목록
   - 예상 장단점 분석 (N≥2인 경우)
   - 복잡도 추정 (low/medium/high)
4. **검증**: 기획서와 출력 일치 여부 확인

#### 출력 예시 - N=1 (단일 구현)

```
접근법 1:
  - 이름: "JWT 토큰 기반 인증"
  - 추가 의존성: [jsonwebtoken, bcrypt]
  - 변경 대상 파일: [src/auth/, src/middleware/, tests/auth/]
  - 구현 가이드: [상세 단계들...]
  - 복잡도: Medium
```

#### 출력 예시 - N≥2 (다중 구현 비교)

```
접근법 1:
  - 이름: "JWT 토큰 기반 인증"
  - 추가 의존성: [jsonwebtoken, bcrypt]
  - 변경 대상 파일: [src/auth/, src/middleware/]
  - 장점: 확장성 좋음, MSA 친화적
  - 단점: 토큰 무효화 복잡
  - 복잡도: Medium

접근법 2:
  - 이름: "세션 기반 인증"
  - 추가 의존성: [express-session]
  - 변경 대상 파일: [src/auth/, src/middleware/, src/config/]
  - 장점: 구현 단순, 즉시 무효화 가능
  - 단점: 서버 메모리 사용, 확장성 제한
  - 복잡도: Low
```

#### 체크포인트: 구현 계획 확인 (필수)

Phase 1이 완료되면, 시스템은 **자동으로 일시정지**하고 사용자의 확인을 기다린다.

**사용자가 확인할 사항**:
1. `approaches.json` 파일 검토
2. 각 구현 방법의 기술 스택이 적절한지 확인
3. 구현 가이드가 기획 의도와 일치하는지 확인

**사용자 선택**:
- **✅ 승인 (Approve)**:
  - CLI: `python -m orchestrator.main approve task-XXX`
  - 구현 계획이 정확하면 Phase 2로 진행
- **🔄 수정 (Revise)**:
  - CLI: `python -m orchestrator.main revise task-XXX --feedback "수정사항"`
  - Architect에게 피드백 전달하여 Phase 1 재실행
- **❌ 중단 (Abort)**:
  - CLI: `python -m orchestrator.main abort task-XXX`
  - 전체 작업 취소

**참고**: 이 체크포인트는 잘못된 구현 방향을 **구현 전에** 차단하여 시간과 비용을 절약합니다.

---

### 3.3 Phase 2: Implementation (구현)

**주체**: Implementer AI Agent(s) (N=1이면 1개, N≥2면 병렬 실행)
**입력**: 각 Agent는 하나의 접근법
**출력**: 독립적인 구현 결과물 (1개 또는 N개)

#### 핵심 개념: git worktree 기반 작업 공간

각 구현은 타겟 프로젝트의 **git worktree**로 생성된다. worktree는 동일한 git 저장소를 공유하면서 각각 독립적인 작업 디렉토리와 브랜치를 가진다.

**시스템이 자동으로 수행하는 작업**:
1. 타겟 프로젝트를 `config.yaml`의 `target_repo`에서 clone (최초 1회)
2. 각 구현마다 git worktree 생성 및 전용 브랜치 할당

```bash
# 시스템이 내부적으로 실행하는 명령 (사용자가 직접 실행할 필요 없음)
git clone https://github.com/user/my-web-app .cache/my-web-app
git worktree add implementations/impl-1 -b task-001/impl-1
git worktree add implementations/impl-2 -b task-001/impl-2
```

**결과 디렉토리 구조**:

```
tasks/task-001/implementations/
├── impl-1/                    # worktree (branch: task-001/impl-1)
│   ├── src/                   # 타겟 프로젝트의 전체 파일
│   ├── package.json
│   ├── (기존 프로젝트 파일 전부)
│   └── .multi-agent/          # 시스템 메타 파일
│       └── work-done.md
└── impl-2/                    # worktree (branch: task-001/impl-2)
    ├── src/
    ├── package.json
    ├── (기존 프로젝트 파일 전부)
    └── .multi-agent/
        └── work-done.md
```

**git worktree의 장점**:
- 각 impl이 **실제 프로젝트 전체**를 가지므로 기존 코드 맥락에서 구현 가능
- git 객체 데이터베이스를 공유하므로 디스크 사용량 효율적
- 각 worktree는 독립된 브랜치에서 작업하므로 상호 간섭 없음
- 사용자가 나중에 `git merge`, `git cherry-pick` 등으로 통합 가능

#### 작업 내용
각 Implementer는:
1. 할당된 접근법에 따라 기존 프로젝트 위에 코드 작성
2. 적절한 에러 처리 포함
3. 기본 테스트 작성 (또는 테스트 가능하도록 설계)
4. `.multi-agent/work-done.md`에 구현 내용 문서화
5. 의존성 변경이 있으면 패키지 매니저로 설치 (`npm install`, `pip install` 등)

---

### 3.4 Phase 3: Review & Testing (리뷰 및 테스트)

**주체**: Reviewer Agent(s) + Tester Agent(s) (각 구현마다 1개씩)
**입력**: 각 구현 결과물
**출력**: 리뷰 보고서 + 테스트 결과 (각 구현마다)

#### Reviewer Agent의 역할

**공통 리뷰 기준**:
1. **코드 품질 평가**: 가독성, 유지보수성, 일관성
2. **설계 분석**: 아키텍처 패턴, 의존성 관리
3. **평가 점수**: 1-5점 스케일

**분야별 추가 리뷰 기준** (Agent가 프로젝트 코드를 분석하여 자동 적용):

*Backend (Node.js, Python, Go 등)*:
- 보안: SQL injection, XSS, CSRF 방지
- 성능: 쿼리 최적화, 캐싱 전략
- 확장성: 수평 확장 가능성
- API 설계: RESTful 원칙, 일관된 응답 형식

*Frontend (React, Vue, Angular 등)*:
- 접근성: ARIA 레이블, 시맨틱 HTML, 키보드 네비게이션
- 성능: 번들 크기, 렌더링 최적화, Core Web Vitals
- 반응형 디자인: 모바일, 태블릿, 데스크톱
- 사용자 경험: 로딩 상태, 에러 처리, 빈 상태

*CLI (Python Click, Node.js Commander 등)*:
- 사용자 경험: 명확한 도움말, 진행 표시
- 에러 메시지 품질: 이해하기 쉬운 설명, 해결 방법 제시
- 플랫폼 호환성: Windows, Linux, macOS
- 성능: 시작 시간, 응답성

*Library/Package*:
- API 설계: 직관성, 일관성, 문서화
- 하위 호환성: Breaking change 최소화
- 의존성: 최소화, 선택적 의존성
- 예제 및 문서: 충분한 사용 예시

#### Tester Agent의 역할

**공통 테스트 전략**:
1. **기본 테스트 작성**: 주요 기능, 엣지 케이스
2. **테스트 실행**: 실제 동작 확인
3. **결과 문서화**: 통과/실패 여부, 커버리지
4. **버그 리포트**: 발견된 문제점 상세 기록

**분야별 테스트 전략** (Agent가 프로젝트 코드를 분석하여 자동 적용):

*Backend*:
- API 테스트: 엔드포인트별 요청/응답 검증
- 통합 테스트: 데이터베이스 연동 (mock 또는 실제 DB)
- 인증/권한 테스트: 토큰 검증, 권한 체크
- 에러 케이스: 잘못된 입력, 네트워크 오류

*Frontend*:
- 컴포넌트 테스트: React Testing Library, Vue Test Utils
- 사용자 인터랙션: 클릭, 입력, 폼 제출
- 접근성 테스트: axe-core 자동 검사
- 스냅샷 테스트: UI 변경 감지 (선택)

*CLI*:
- 입출력 테스트: 명령어 실행 후 출력 검증
- Exit code 검증: 성공/실패 상태 확인
- 에러 메시지 테스트: 잘못된 명령어, 옵션
- 플랫폼별 동작: 주요 OS에서 실행 확인

*Library*:
- API 테스트: 모든 공개 함수/클래스 테스트
- 예제 코드 실행: README의 예제가 실제 동작하는지
- 에지 케이스: null, undefined, 빈 배열 등

---

### 3.5 Phase 4: Comparison (비교 분석, N≥2인 경우에만)

**주체**: Comparator AI Agent
**입력**: N개 구현 + 각각의 리뷰 + 각각의 테스트 결과
**출력**: 종합 비교 보고서 및 추천 순위

**참고**: N=1인 경우 이 단계는 생략되고 바로 Phase 6 (통합)으로 이동합니다.

#### 작업 내용
1. **정량적 비교**
   - 테스트 통과율
   - 코드 복잡도
   - 성능 지표 (있는 경우)
   - 리뷰 점수

2. **정성적 비교**
   - 유지보수 용이성
   - 확장 가능성
   - 팀의 기술 스택과의 적합성
   - 장기적 리스크

3. **순위 산정**
   - 모든 요소를 종합하여 1위부터 N위까지 순위 결정
   - 각 순위의 근거 명시

#### 출력 형식
```
=== 비교 분석 결과 ===

추천 순위: [2, 1, 3]

1위: 접근법 2 (세션 기반 인증)
  - 이유: 구현 완성도 높음, 테스트 100% 통과, 유지보수 용이
  - 점수: 4.5/5.0

2위: 접근법 1 (JWT 기반)
  - 이유: 확장성은 우수하나 토큰 무효화 로직 미완성
  - 점수: 3.8/5.0

3위: 접근법 3 (OAuth2 하이브리드)
  - 이유: 복잡도가 높고 현재 요구사항 대비 과도한 설계
  - 점수: 3.2/5.0
```

---

### 3.6 Phase 5: Human Selection (사람의 선택, N≥2인 경우에만)

**주체**: 사람 (개발자/팀)
**입력**: 비교 분석 보고서
**출력**: 최종 선택 결정 (decision.json)

**참고**: N=1인 경우 이 단계는 생략되고 바로 Phase 6 (통합)으로 이동합니다.

#### 핵심 개념: 파이프라인 일시정지
이 단계에서 시스템은 **자동 실행을 멈추고** 사람의 입력을 기다린다.

#### 제공되는 정보
1. 각 구현의 실제 코드
2. 리뷰 보고서
3. 테스트 결과
4. 비교 분석 및 추천 순위

#### 사람의 역할
1. **정보 검토**: AI가 제공한 모든 분석 자료 확인
2. **직접 평가**: 필요시 코드를 직접 확인
3. **맥락 고려**: AI가 모르는 팀 상황, 정치적 요인, 전략적 방향 고려
4. **최종 결정**: 어느 구현을 선택할지 결정

#### 결정 방식
`decision.json` 파일 생성:
```
{
  "selected_id": 2,
  "action": "approve",
  "reason": "우리 팀의 기술 스택과 가장 잘 맞고, 유지보수가 용이함"
}
```

---

### 3.7 Phase 6: Integration (통합)

**주체**: 사람 (git 기반 수동 통합)
**입력**:
- N=1: 유일한 구현의 브랜치 (`task-XXX/impl-1`)
- N≥2: 사용자가 선택한 구현의 브랜치 (`task-XXX/impl-N`)
**출력**: 메인 브랜치에 통합된 코드

#### 왜 사람이 직접 통합하는가?

코드 통합은 **프로젝트의 git 히스토리에 영향을 미치는 중요한 작업**이다. AI가 자동으로 merge/rebase를 수행하면:
- 예상치 못한 충돌 해결로 코드가 깨질 수 있음
- git 히스토리가 오염될 수 있음
- 사용자가 의도하지 않은 변경이 포함될 수 있음

따라서 통합은 사용자가 직접 git 명령으로 수행한다.

#### 작업 방식

시스템이 Phase 5까지 완료하면, 사용자에게 통합할 브랜치 정보를 알림으로 전달한다.

```bash
# N=1: 단일 구현 통합
git merge task-001/impl-1

# N≥2: 선택한 구현 통합
git merge task-001/impl-2    # 또는 cherry-pick으로 부분 통합

# 통합 후 확인
git diff main..HEAD
git log --oneline

# 미사용 worktree 정리 (선택)
git worktree remove implementations/impl-1
git worktree remove implementations/impl-2
```

#### 시스템이 제공하는 정보
- 통합 대상 브랜치명 (`task-XXX/impl-N`)
- 해당 브랜치의 변경 요약 (변경된 파일 목록, 추가/삭제 라인 수)
- 리뷰/테스트 결과 요약
- N≥2인 경우 비교 보고서 및 추천 순위

---

## 4. 핵심 설계 원칙

### 4.1 원자적 연산 (Atomic Operations)

#### 문제
여러 AI Agent가 동시에 실행될 때 파일 쓰기 충돌 가능성이 있다.

#### 해결
모든 파일 쓰기를 **원자적**으로 수행한다:
1. 임시 파일에 먼저 쓰기 (`file.tmp`)
2. 쓰기 완료 후 원본 파일명으로 원자적 이동
3. 이동은 운영체제 수준에서 원자적 연산 보장

---

### 4.2 환경 격리 (Environment Isolation)

#### 개념
각 구현은 타겟 프로젝트의 **git worktree**로 생성되어, 독립적인 브랜치와 작업 디렉토리를 가진다.

#### 전략
- **git worktree**: 각 구현(impl-N)마다 전용 worktree와 브랜치(`task-XXX/impl-N`) 생성
- **git 객체 공유**: worktree 간 `.git` 객체 데이터베이스 공유로 디스크 효율적
- **독립된 의존성**: 각 worktree에서 필요시 `npm install`, `pip install` 등 독립 실행
- **통합은 사용자 주도**: 코드 통합은 사용자가 `git merge`, `git cherry-pick` 등으로 직접 수행

**참고**: N=1인 경우에도 동일하게 worktree로 생성한다. 격리 목적이 아닌, 기존 프로젝트 위에서 작업하기 위한 구조이다.

---

### 4.3 관찰 가능성 (Observability)

#### 원칙
모든 단계의 상태와 진행 상황을 실시간으로 파악할 수 있어야 한다.

#### 구현
1. **상태 파일** (manifest.json): 현재 어느 단계인지
2. **타임라인** (timeline.log): 각 단계의 시작/완료 시각
3. **알림 시스템**: OS 네이티브 알림으로 주요 이벤트 통지
4. **로그**: 상세한 실행 로그

---

### 4.4 실패 처리 (Failure Handling)

#### 원칙
구현 중 오류가 발생해도 체계적으로 처리하여 정보를 제공한다.

#### 전략
- **자동 재시도**: 일시적 오류는 자동으로 재시도
- **타임아웃**: 무한 대기 방지
- **에러 추적**: 실패 원인 상세 기록
- **부분 성공** (N≥2인 경우): 일부 구현이 실패해도 성공한 구현들끼리 비교 진행
- **실패 알림** (N=1인 경우): 구현 실패 시 사용자에게 즉시 알림

---

## 5. 시스템의 장점

### 5.1 품질 향상
- ✅ 여러 솔루션 중 실제로 최선을 선택
- ✅ 코드 리뷰와 테스트가 자동으로 수행됨
- ✅ 객관적 비교 데이터 기반 의사결정

### 5.2 리스크 감소
- ✅ 자동화된 리뷰와 테스트로 문제 조기 발견
- ✅ 여러 구현 비교 시(N≥2) 대안 확보로 실패 방지
- ✅ 기술적 부채 발생 전에 검증 (N≥2인 경우 여러 옵션 비교)

### 5.3 학습 효과
- ✅ 리뷰 보고서를 통해 코드 품질 개선점 학습 (N=1)
- ✅ 여러 구현 방식을 비교하며 학습 (N≥2)
- ✅ 왜 특정 접근법이 더 나은지 데이터로 확인 (N≥2)
- ✅ 팀 전체의 기술적 역량 향상

### 5.4 시간 효율성
- ✅ N=1 (일반 케이스): 자동화된 품질 관리로 리뷰/테스트 시간 절약
- ✅ N>1 (비교 케이스): AI 병렬 실행으로 순차 개발 대비 시간 절약
- ✅ 사용자 선택: 상황에 맞게 N을 결정하여 속도 조절 가능
- ✅ 자동화된 프로세스: 사람이 직접 리뷰/테스트할 필요 없음

---

## 6. 활용 시나리오

### 6.1 백엔드: 일반적인 기능 개발 (N=1)
**상황**: 사용자 인증 기능을 추가하고 싶다. JWT 방식으로 구현하면 될 것 같다.

**타겟 프로젝트**: Node.js 백엔드

**해결**:
1. 기획서에 JWT 인증 구현 명시 (N=1, backend-node)
2. AI 개발팀이 구현 + 보안/성능 리뷰 + API 테스트 자동 수행
3. 품질 보증된 구현을 받아서 통합

**장점**: 빠른 개발, 자동화된 품질 관리, 사람은 기획과 통합만 담당

---

### 6.2 백엔드: 기술 선택 결정 (N≥2)
**상황**: 인증 시스템을 도입하려는데 JWT와 세션 중 뭐가 좋을지 확실하지 않다.

**타겟 프로젝트**: Node.js 백엔드

**해결**:
1. 두 방법을 기획서에 명시 (N=2, backend-node)
2. AI 개발팀이 두 가지를 병렬로 구현
3. 각각 보안/성능 리뷰 + API 테스트 자동 수행
4. 비교 보고서를 보고 데이터 기반으로 결정

**장점**: 실제 구현을 보고 결정, 객관적 비교, 리스크 감소

---

### 6.3 프론트엔드: 상태 관리 라이브러리 선택 (N≥2)
**상황**: React 프로젝트에서 전역 상태 관리가 필요하다. Context API, Zustand, Jotai 중 무엇이 좋을지 고민이다.

**타겟 프로젝트**: React 프론트엔드

**해결**:
1. 세 방법을 기획서에 명시 (N=3, frontend-react)
2. AI 개발팀이 세 가지를 병렬로 구현
3. 각각 성능(렌더링 최적화), 번들 크기, 개발자 경험 리뷰
4. 컴포넌트 테스트 및 번들 크기 측정
5. 비교 보고서로 팀 상황에 가장 적합한 선택

**장점**: 실제 성능 데이터 확보, 번들 크기 비교, 학습 곡선 파악

---

### 6.4 프론트엔드: UI 컴포넌트 구현 (N=1)
**상황**: 접근성을 고려한 모달 컴포넌트가 필요하다.

**타겟 프로젝트**: React 프론트엔드

**해결**:
1. 기획서에 접근성 요구사항 포함 (N=1, frontend-react)
2. AI 개발팀이 ARIA 속성, 키보드 네비게이션, 포커스 관리 포함하여 구현
3. 접근성 리뷰 (axe-core), 컴포넌트 테스트 자동 수행
4. 접근성 검증된 컴포넌트 통합

**장점**: 접근성 표준 준수, 자동화된 검증, 수동 테스트 시간 절약

---

### 6.5 CLI: 도구 개발 (N=1)
**상황**: 파일 변환 CLI 도구를 만들고 싶다. JSON을 YAML로 변환하는 간단한 도구다.

**타겟 프로젝트**: Python CLI

**해결**:
1. 기획서에 CLI 기능 명시 (N=1, cli-python)
2. AI 개발팀이 Click 프레임워크로 구현, 진행 바 추가, 에러 메시지 개선
3. UX 리뷰 (도움말 명확성, 에러 메시지), 입출력 테스트
4. 사용자 친화적인 CLI 도구 완성

**장점**: 사용자 경험 자동 검증, 다양한 에러 케이스 테스트

---

### 6.6 학습 목적 탐색 (N≥2)
**상황**: 레거시 코드 리팩토링 방법을 배우고 싶다. 여러 방법을 비교해보고 싶다.

**타겟 프로젝트**: 기존 프로젝트에 따라 결정

**해결**:
1. 3-4가지 리팩토링 전략을 기획서에 명시 (N=3~4)
2. AI 개발팀이 모두 구현
3. 비교 보고서로 각 방법의 장단점 학습
4. 가장 적합한 방법 선택

**장점**: 실제 구현으로 학습, 여러 접근법 비교, 팀 역량 향상

---

## 7. 제약사항 및 고려사항

### 7.1 비용

API 사용 비용은 구현 개수(N)에 비례합니다:

| 구현 개수 | 상대 비용 | 적용 상황 |
|----------|---------|----------|
| N=1 | 1배 (기준) | 일반적인 기능 개발 |
| N=2 | 2배 | 두 가지 방법 비교 |
| N=3+ | 3배 이상 | 여러 방법 깊이 비교 |

**비용 고려사항**:
- N=1이 일반적 케이스이므로 기본 비용은 합리적
- N>1은 선택사항이므로 사용자가 비용 대비 가치를 판단하여 결정
- 품질 관리(리뷰/테스트)는 N과 무관하게 항상 수행됨

### 7.2 시간

개발 시간은 구현 개수(N)와 병렬 실행 여부에 따라 결정됩니다:

| 구현 개수 | 예상 시간 | 설명 |
|----------|---------|------|
| N=1 | 기준 시간 | 구현 → 리뷰 → 테스트 → 통합 |
| N=2 | ~1.5배 | 2개 병렬 구현 + 비교 분석 |
| N=3+ | ~2배 | N개 병렬 구현 + 비교 분석 |

**시간 고려사항**:
- N=1은 순차적 개발보다 빠름 (자동화된 리뷰/테스트)
- N>1은 병렬 실행으로 순차 구현보다 빠름
- 비교 분석 단계가 추가되지만, 의사결정 시간 단축

### 7.3 적용 범위

이 시스템은 **품질 관리가 중요한 모든 소프트웨어 개발 작업**에 적용 가능합니다.

#### 적용 가능한 프로젝트

GitHub 저장소로 관리되는 모든 소프트웨어 프로젝트에 적용 가능하다. 시스템은 타겟 프로젝트를 clone하여 기존 코드 위에서 작업하므로, 프로젝트의 언어나 프레임워크에 제한이 없다.

- Backend API (Node.js, Python, Go, Rust 등)
- Frontend Web (React, Vue, Angular, Svelte 등)
- Mobile App (React Native, Flutter)
- CLI Tool (Python, Node.js, Rust 등)
- Library/Package (npm, PyPI, crates.io 등)
- Data Analysis, ML Model 등

Reviewer Agent와 Tester Agent는 실제 프로젝트의 코드를 분석하여 적절한 리뷰 기준과 테스트 전략을 자체적으로 판단한다.

#### 사용 케이스별 적용

**✅ N=1로 사용 (일반적)**:
- 일상적인 기능 추가
- 버그 수정 (복잡한 경우)
- 표준적인 구현 패턴
- 자동화된 리뷰/테스트가 필요한 모든 작업

**✅ N≥2로 사용 (선택사항)**:
- 여러 기술 스택 중 선택이 필요할 때
- 중요한 아키텍처 결정
- 리팩토링 전략 비교
- 학습 목적의 접근법 비교
- 단순 호기심 ("다른 방법은?")

**❌ 부적합한 경우**:
- 긴급 핫픽스 (시간이 가장 중요)
- 오타 수정, 포맷 변경 (품질 관리 불필요)
- 단순 반복 작업

---

## 8. 확장 가능성

### 8.1 플러그인 시스템
- 사용자 정의 Agent 추가 가능
- 사용자 정의 평가 기준 추가 가능

### 8.2 팀 협업 도구 통합
- Slack, Discord 알림 통합
- GitHub PR 자동 생성
- 팀 대시보드

### 8.3 학습 기능
- 과거 선택 패턴 학습
- 성공적인 접근법 우선 제안
- 실패 패턴 회피

---

## 9. 리스크 및 완화 방안

| 리스크 | 영향 | 완화 방안 |
|--------|------|-----------|
| 불명확한 기획서 | 잘못된 구현 방향 | 기획 템플릿 제공, **Spec Validation 자동 검증** (3.1.1절) |
| AI 실행 실패 | 파이프라인 중단 | 자동 재시도, 타임아웃, 부분 성공 허용 |
| 리소스 과다 사용 | 비용/시간 증가 | N 값 제한, 병렬 실행 제한 설정 |
| 구현 품질 불균일 | 비교 어려움 | 명확한 프롬프트, 품질 기준 통일 |

---

## 10. 결론

본 제안서는 **다중 AI 에이전트 기반 개발 시스템**을 통해 소프트웨어 개발의 새로운 패러다임을 제시한다.

### 핵심 가치

1. **품질 중심 개발**: 자동화된 리뷰와 테스트로 모든 구현의 품질 보장
2. **유연한 탐색**: 필요시 여러 방법을 비교하여 최선의 선택 (선택사항)
3. **인간-AI 협업**: 사람은 기획과 의사결정, AI는 구현과 품질 관리
4. **데이터 기반 의사결정**: 실제 구현 결과와 테스트 데이터로 판단

### 기대 효과

- ✅ **품질 향상**: 자동화된 리뷰와 테스트로 품질 보장
- ✅ **시간 절약**: 사람이 직접 리뷰/테스트할 필요 없음
- ✅ **유연성**: 상황에 맞게 N=1 또는 N>1 선택 가능
- ✅ **학습 효과**: 여러 구현을 비교하며 성장 (N>1 선택 시)

### 적용 분야

#### 적용 대상
- GitHub 저장소로 관리되는 모든 소프트웨어 프로젝트
- 언어/프레임워크 제한 없음 (프로젝트를 clone하여 기존 코드 위에서 작업)

#### 일상적 사용 (N=1)
- 일반적인 기능 개발
- 복잡한 버그 수정
- 자동화된 품질 관리가 필요한 모든 작업

#### 선택적 비교 (N≥2)
- 여러 기술 스택 중 선택이 필요할 때
- 중요한 아키텍처 결정
- 리팩토링 전략 비교
- 학습 및 교육 목적

---

*끝*
